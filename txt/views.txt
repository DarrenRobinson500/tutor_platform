from rest_framework import viewsets
from .validation import *
from .rendering import *
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
import yaml
from .import_skills import *
from .ai import generate_template_content
from .utilities import *
from .serializers import *

class TemplateViewSet(viewsets.ModelViewSet):
    queryset = Template.objects.all()
    serializer_class = TemplateSerializer

    @action(detail=False, methods=["post"])
    def autosave(self, request):
        content = request.data.get("content", "")
        template_id = request.data.get("templateId") or request.data.get("id")
        if not template_id or template_id == "undefined":
            return Response({"error": "templateId required"}, status=400)

        # Debug print so you can see autosave firing
        # print("AUTOSAVE RECEIVED", template_id, request.data)

        # If no template_id, do nothing and return success
        if not template_id:
            return Response({"ok": True})

        # If template_id exists, update the template
        try:
            template = Template.objects.get(pk=template_id)
            template.content = content
            template.save()
            # print(f"AUTOSAVED TEMPLATE {template_id}")
            return Response({"ok": True})
        except Template.DoesNotExist:
            # Silently ignore missing templates too
            return Response({"ok": True})

    @action(detail=False, methods=["post"])
    def preview(self, request):
        content = request.data.get("content", "")

        # Step 1: Try YAML
        try:
            parsed = yaml.safe_load(content)
        except Exception as e:
            return Response(
                {"ok": False, "error": f"YAML error: {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Step 2: Deep validation (your rules)
        errors = validate_template(parsed)
        if errors:
            return Response(
                {"ok": False, "preview": parsed, "error": errors},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Step 3: Render preview (your logic)
        MAX_ATTEMPTS = 5
        last_error = None

        for attempt in range(MAX_ATTEMPTS):
            try:
                preview = render_template_preview(parsed)
                print("PREVIEW RETURNED FROM BACKEND:", preview)

                return Response({"ok": True, "preview": preview})
            except Exception as e:
                import traceback
                print("\n--- PREVIEW ERROR ATTEMPT", attempt, "---")
                traceback.print_exc()
                last_error = str(e)

        # If all attempts failed, return the last error
        return Response(
            {
                "ok": False,
                "error": f"Failed after {MAX_ATTEMPTS} attempts: {last_error}"
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    @action(detail=False, methods=["post"])
    def generate(self, request):
        skill_id = request.data.get("skill_id")

        if not skill_id:
            return Response({"error": "skill_id missing"}, status=400)
        try:
            skill = Skill.objects.get(id=skill_id)
        except Skill.DoesNotExist:
            return Response({"error": "Skill not found"}, status=404)

        print("\nSkill:\n", skill.description)
        data = generate_template_content(skill.description)
        print("AI Output:\n", data)

        created_templates = []

        for item in data:
            template = Template.objects.create(
                skill=skill,
                subject=item["title"],
                content=format_for_editor(item),
            )
            created_templates.append(template)

        # Return ONLY the first created template
        first = created_templates[0]

        return Response({
            "id": first.id,
            "subject": first.subject,
            "content": first.content,
            "skill": first.skill.id,
        })

    @action(detail=True, methods=["post"])
    def diagram(self, request, pk=None):
        template = self.get_object()
        svg = request.data.get("svg")

        if not svg:
            return Response({"error": "SVG missing"}, status=400)

        diagram, _ = TemplateDiagram.objects.update_or_create(
            template=template,
            defaults={"svg_spec": svg}
        )

        return Response({"ok": True})


class SkillViewSet(viewsets.ModelViewSet):
    queryset = Skill.objects.all().order_by("order_index")

    def get_serializer_class(self):
        if self.action in ["retrieve", "children"]:
            return SkillDetailSerializer
        return SkillSerializer

    @action(detail=True, methods=["get"])
    def children(self, request, pk=None):
        parent = self.get_object()
        children = parent.children.order_by("order_index")
        serializer = SkillSerializer(children, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=["get"])
    def direct_templates(self, request, pk=None):
        skill = self.get_object()
        templates = skill.direct_templates()
        serializer = TemplateSerializer(templates, many=True)
        return Response(serializer.data)

    def list(self, request, *args, **kwargs):
        parent_id = request.query_params.get("parent")
        if parent_id:
            skills = Skill.objects.filter(parent_id=parent_id).order_by("order_index")
        else:
            skills = Skill.objects.filter(parent__isnull=True).order_by("order_index")

        serializer = SkillSerializer(skills, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=["get"])
    def parents(self, request, pk=None):
        skill = self.get_object()
        chain = []
        current = skill.parent

        while current:
            chain.append(current)
            current = current.parent

        # reverse so it goes root → child → current
        chain.reverse()

        serializer = SkillSerializer(chain, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=["post"])
    def load_syllabus(self, request):
        # Safety: prevent accidental double-import
        from app.models import Skill
        if Skill.objects.exists():
            return Response({"error": "Skills already exist. Clear them first."}, status=400)

        import_syllabus()
        return Response({"status": "Syllabus loaded successfully"})


    def destroy(self, request, *args, **kwargs):
        skill = self.get_object()

        if skill.children.exists():
            return Response(
                {"error": "Cannot delete a skill that has sub-skills."},
                status=400
            )

        return super().destroy(request, *args, **kwargs)

    @action(detail=True, methods=["post"])
    def diagram(self, request, pk=None):
        template = self.get_object()
        svg = request.data.get("svg")

        if not svg:
            return Response({"error": "SVG missing"}, status=400)

        diagram, _ = TemplateDiagram.objects.update_or_create(
            template=template,
            defaults={"svg_spec": svg}
        )

        return Response({"ok": True})

