class TutorViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = User.objects.filter(role="tutor").order_by("username")
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]

    @action(detail=True, methods=["get"])
    def home(self, request, pk=None):
        tutor = self.get_object()
        return Response({
            "id": tutor.id,
            "name": tutor.get_full_name() or tutor.username,
            "email": tutor.email,
        })

    @action(detail=True, methods=["get"])
    def templates(self, request, pk=None):
        tutor = self.get_object()
        templates = Template.objects.filter(created_by=tutor)
        serializer = TemplateSerializer(templates, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=["get"])
    def students(self, request, pk=None):
        tutor = self.get_object()
        students = User.objects.filter(tutors__tutor=tutor)
        serializer = UserSerializer(students, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=["post"])
    def create_tutor(self, request):
        name = request.data.get("name")
        email = request.data.get("email")
        password = request.data.get("password") or User.objects.make_random_password()

        if not name or not email:
            return Response({"error": "Name and email are required"}, status=400)

        new_tutor = User.objects.create(
            username=email,
            email=email,
            first_name=name,
            role="tutor",
            password=make_password(password),
        )

        TutorProfile.objects.create(tutor=new_tutor)

        return Response({
            "id": new_tutor.id,
            "name": new_tutor.first_name,
            "email": new_tutor.email,
            "password": password
        })

    @action(detail=True, methods=["get"])
    def availability(self, request, pk=None):
        tutor = self.get_object()

        availability = TutorAvailability.objects.filter(tutor=tutor)
        blocked = TutorBlockedDay.objects.filter(tutor=tutor)

        return Response({
            "availability": [
                {
                    "id": a.id,
                    "weekday": a.weekday,
                    "start_time": a.start_time,
                    "end_time": a.end_time,
                }
                for a in availability
            ],
            "blocked_days": [
                {
                    "id": b.id,
                    "date": b.date,
                }
                for b in blocked
            ]
        })

    @action(detail=True, methods=["post"])
    def add_availability(self, request, pk=None):
        tutor = self.get_object()
        js_weekday = int(request.data["weekday"])
        weekday = (js_weekday - 1) % 7
        start = request.data.get("start_time")
        end = request.data.get("end_time")

        a = TutorAvailability.objects.create(
            tutor=tutor,
            weekday=weekday,
            start_time=start,
            end_time=end,
        )

        return Response({"id": a.id})

    @action(detail=True, methods=["post"])
    def remove_availability(self, request, pk=None):
        TutorAvailability.objects.filter(id=request.data.get("id")).delete()
        return Response({"status": "ok"})

    @action(detail=True, methods=["post"])
    def block_day(self, request, pk=None):
        tutor = self.get_object()
        date = request.data.get("date")
        b = TutorBlockedDay.objects.create(tutor=tutor, date=date)
        return Response({"id": b.id})


    @action(detail=True, methods=["post"])
    def unblock_day(self, request, pk=None):
        TutorBlockedDay.objects.filter(id=request.data.get("id")).delete()
        return Response({"status": "ok"})

    # @action(detail=True, methods=["get"])
    # def settings(self, request, pk=None):
    #     tutor = self.get_object()
    #     serializer = TutorSerializer(tutor)
    #     return Response(serializer.data)
    #
    @action(detail=True, methods=["get"])
    def weekly_slots(self, request, pk=None):
        user = self.get_object()
        tutor = user.get_tutor_profile()
        student_id = request.query_params.get("student")
        student = User.objects.filter(pk=student_id).first()
        print("Weekly slots (student)", student_id, student)

        week_start_str = request.query_params.get("week_start")
        if not week_start_str:
            return Response({"error": "week_start is required (YYYY-MM-DD)"}, status=400)

        try:
            raw_date = datetime.strptime(week_start_str, "%Y-%m-%d").date()
        except ValueError:
            return Response({"error": "Invalid date format. Use YYYY-MM-DD."}, status=400)

        week_start = get_sunday_start(raw_date)
        week_data = tutor.generate_weekly_slots(week_start, student)

        return Response({"week": week_data}, status=200)

    @action(detail=True, methods=["get"])
    def session_settings(self, request, pk=None):
        user = self.get_object()
        print("Session settings user", user)
        tutor = TutorProfile.objects.get(tutor=user)
        print(tutor)
        serializer = TutorSerializer(tutor)
        return Response(serializer.data)

    @action(detail=True, methods=["post"], url_path="check_and_book")
    def check_and_book(self, request, pk=None):
        print("Check and book")
        user = self.get_object()
        tutor = user.get_tutor_profile()

        student_id = request.data["student_id"]
        student = User.objects.get(pk=student_id)
        date = request.data["date"]  # "2026-02-01"
        time = request.data["time"]  # "09:00"
        repeat = request.data.get("repeat_weekly", False)

        print("Check and book (user, tutor, studentid, date, time, repeat)",
              user, tutor, student_id, date, time, repeat)

        # Parse date + time
        date_dt = datetime.fromisoformat(date).date()
        start_t = datetime.strptime(time, "%H:%M").time()

        # Compute end time
        session_minutes = tutor.default_session_minutes
        end_t = (datetime.combine(date_dt, start_t) + timedelta(minutes=session_minutes)).time()

        print("Check and book (date_dt, start_t, end_t)", date_dt, start_t, end_t)

        # Weekly repetition
        weeks = 12 if repeat else 1
        created = 0

        for i in range(weeks):
            this_date = date_dt + timedelta(weeks=i)

            # Build naive datetimes
            naive_start = datetime.combine(this_date, start_t)
            naive_end = datetime.combine(this_date, end_t)

            # Localize to Sydney timezone
            start_dt = make_aware(naive_start)
            end_dt = make_aware(naive_end)

            # Availability check
            if tutor.is_available(this_date, start_t, end_t):
                Appointment.objects.create(
                    tutor=user,
                    student_id=student_id,
                    start_datetime=start_dt,
                    end_datetime=end_dt,
                    status="booked",
                    created_by=student,
                )
                created += 1

        return Response({
            "status": "ok",
            "message": f"Appointment booked ({created} sessions)"
        })

    @action(detail=True, methods=["post"], url_path="delete_booking")
    def delete_booking(self, request, pk=None):
        user = self.get_object()  # the tutor in tutor_view OR the tutor of the student

        booking_id = request.data.get("booking_id")
        if not booking_id:
            return Response({"error": "booking_id is required"}, status=400)
        try:
            appt = Appointment.objects.get(id=booking_id)
        except Appointment.DoesNotExist:
            return Response({"error": "Appointment not found"}, status=404)

        appt.delete()
        return Response({"status": "ok", "message": "Booking deleted"})
