from .models import *


# ----------- STUDENTS ------------------

STUDENTS_CACHE = {}

def get_cached_students_for_tutor(tutor):
    tutor_id = tutor.id

    if tutor_id not in STUDENTS_CACHE:
        # Build fresh
        links = TutorStudent.objects.filter(tutor=tutor).select_related(
            "student__student_profile"
        )

        data = []
        for link in links:
            student_user = link.student
            profile = student_user.get_student_profile()

            data.append({
                "user_id": student_user.id,
                "profile_id": profile.id,
                "first_name": student_user.first_name,
                "last_name": student_user.last_name,
                "email": student_user.email,
                "year_level": profile.year_level,
                "area_of_study": profile.area_of_study,
            })

        STUDENTS_CACHE[tutor_id] = data

    return STUDENTS_CACHE[tutor_id]

def invalidate_students_cache_for_tutor(tutor_id):
    if tutor_id in STUDENTS_CACHE:
        del STUDENTS_CACHE[tutor_id]


# ------------WEEKLY SLOTS -------------

WEEKLY_SLOTS_CACHE = {}

def get_cached_weekly_slots(tutor, week_start, student):
    key = (tutor.id, week_start, student.id if student else None)

    if key not in WEEKLY_SLOTS_CACHE:
        WEEKLY_SLOTS_CACHE[key] = tutor.generate_weekly_slots(week_start, student)

    return WEEKLY_SLOTS_CACHE[key]

def invalidate_weekly_slots_cache_for_tutor(tutor_id):
    print("Invalidating Weekly slots cash (tutor id)", tutor_id)
    global WEEKLY_SLOTS_CACHE
    WEEKLY_SLOTS_CACHE = {
        key: value
        for key, value in WEEKLY_SLOTS_CACHE.items()
        if key[0] != tutor_id
    }


# ------------ WEEKLY BOOKING AVAILABILITY -------------

WEEKLY_AVAILABILITY_CACHE = {}

def build_weekly_availability(tutor):
    """
    Builds the full weekly availability structure for a tutor:
      - 15-minute availability slots
      - weekly bookings (with student names)
    """

    # 1. Fetch availability windows
    availability = TutorAvailability.objects.filter(tutor=tutor)

    # 2. Fetch weekly bookings
    bookings = WeeklyBooking.objects.filter(tutor=tutor).select_related("student")

    # Build booking lookup
    booking_map = defaultdict(list)
    for b in bookings:
        booking_map[b.weekday].append({
            "start_time": b.start_time,
            "end_time": b.end_time,
            "student_id": b.student.id,
            "student_name": b.student.first_name,
        })

    # 3. Expand availability into 15-minute slots
    result = {i: {"slots": [], "bookings": booking_map[i]} for i in range(7)}

    for av in availability:
        weekday = av.weekday

        start = datetime.combine(datetime.today(), av.start_time)
        end = datetime.combine(datetime.today(), av.end_time)

        current = start
        while current + timedelta(minutes=15) <= end:
            result[weekday]["slots"].append(current.time())
            current += timedelta(minutes=15)

    return result

def get_cached_weekly_availability(tutor):
    tutor_id = tutor.id

    if tutor_id not in WEEKLY_AVAILABILITY_CACHE:
        WEEKLY_AVAILABILITY_CACHE[tutor_id] = build_weekly_availability(tutor)

    return WEEKLY_AVAILABILITY_CACHE[tutor_id]


def invalidate_weekly_availability_cache_for_tutor(tutor_id):
    if tutor_id in WEEKLY_AVAILABILITY_CACHE:
        del WEEKLY_AVAILABILITY_CACHE[tutor_id]

def mask_weekly_availability_for_student(availability, student_id):
    import copy
    safe = copy.deepcopy(availability)

    for weekday, info in safe.items():
        for b in info["bookings"]:
            if b["student_id"] == student_id:
                b["status"] = "booked_self"
            else:
                b["status"] = "booked_other"

            # Remove identifying info
            b.pop("student_name", None)
            b.pop("student_id", None)

    return safe

# ----------SKILLS ---------------


MATRIX_CACHE = None
GRADES = ["K", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

def flatten_skills(skills, children_map, depth=0):
    flat = []
    for skill in skills:
        flat.append((skill, depth))
        children = children_map.get(skill.id, [])
        flat.extend(flatten_skills(children, children_map, depth + 1))
    return flat


def build_matrix():
    skills = list(
        Skill.objects.all()
        .select_related("parent")
        .order_by("id")
    )

    # Load template counts in one query
    template_counts = {
        (skill_id, grade): count
        for skill_id, grade, count in Template.objects
        .values_list("skill_id", "grade")
        .annotate(count=Count("id"))
    }

    validated_counts = {
        (skill_id, grade): count
        for skill_id, grade, count in Template.objects
        .filter(validated=True)
        .values_list("skill_id", "grade")
        .annotate(count=Count("id"))
    }

    unvalidated_counts = {
        (skill_id, grade): count
        for skill_id, grade, count in Template.objects
        .filter(validated=False)
        .values_list("skill_id", "grade")
        .annotate(count=Count("id"))
    }

    # Build children map
    children_map = {}
    for skill in skills:
        parent_id = skill.parent_id
        children_map.setdefault(parent_id, []).append(skill)

    # Get top-level skills and flatten
    top_level = children_map.get(None, [])
    flat = flatten_skills(top_level, children_map)

    # Build rows
    rows = []
    for skill, depth in flat:
        # No DB hit â€” grades already loaded
        grade_list = [str(g) for g in skill.get_grade_list()]

        cells = {}
        for g in GRADES:
            g_str = str(g)
            colour = "covered" if g_str in grade_list else "empty"
            cells[g_str] = {
                "colour": colour,
                "count": template_counts.get((skill.id, g_str), 0),
                "validated": validated_counts.get((skill.id, g_str), 0),
                "unvalidated": unvalidated_counts.get((skill.id, g_str), 0),
            }

        rows.append({
            "id": skill.id,
            "parent_id": skill.parent_id,
            "code": skill.code,
            "description": skill.description,
            "depth": depth,
            "children_count": len(children_map.get(skill.id, [])),
            "validated_count": validated_counts.get(skill.id, 0),
            "unvalidated_count": unvalidated_counts.get(skill.id, 0),
            "cells": cells,
        })
    # print("Matrix")
    # print(rows[0])
    # print(rows[1])
    return {
        "grades": GRADES,
        "skills": rows
    }


def update_matrix_cache_for_count(skill_id):
    global MATRIX_CACHE
    if MATRIX_CACHE is None:
        return

    # --- Recompute all counts for this skill, grouped by grade ---
    total_counts = {
        grade: count
        for grade, count in Template.objects
            .filter(skill_id=skill_id)
            .values_list("grade")
            .annotate(count=Count("id"))
    }

    validated_counts = {
        grade: count
        for grade, count in Template.objects
            .filter(skill_id=skill_id, validated=True)
            .values_list("grade")
            .annotate(count=Count("id"))
    }

    unvalidated_counts = {
        grade: count
        for grade, count in Template.objects
            .filter(skill_id=skill_id, validated=False)
            .values_list("grade")
            .annotate(count=Count("id"))
    }

    # --- Update only the affected row in the cache ---
    for row in MATRIX_CACHE["skills"]:
        if row["id"] == skill_id:
            for g in GRADES:
                g_str = str(g)
                row["cells"][g_str]["count"] = total_counts.get(g_str, 0)
                row["cells"][g_str]["validated"] = validated_counts.get(g_str, 0)
                row["cells"][g_str]["unvalidated"] = unvalidated_counts.get(g_str, 0)
            break

def get_matrix_cache():
    global MATRIX_CACHE
    if MATRIX_CACHE is None:
        MATRIX_CACHE = build_matrix()   # heavy work
    return MATRIX_CACHE

def filter_matrix_by_grade(matrix, grade):
    grade_str = str(grade)
    rows = matrix["skills"]

    # 1. Find covered leaf skills for this grade
    covered_leaf_ids = {
        r["id"]
        for r in rows
        if r["children_count"] == 0
        and r["cells"][grade_str]["colour"] == "covered"
    }

    # 2. Build parent lookup
    parent_map = {r["id"]: r.get("parent_id") for r in rows}

    # 3. Collect ancestors
    visible_ids = set()

    def add_ancestors(skill_id):
        if skill_id in visible_ids:
            return
        visible_ids.add(skill_id)
        parent_id = parent_map.get(skill_id)
        if parent_id:
            add_ancestors(parent_id)

    for leaf_id in covered_leaf_ids:
        add_ancestors(leaf_id)

    # 4. Filter rows
    return [r for r in rows if r["id"] in visible_ids]
