class TutorViewSet(viewsets.ModelViewSet):

    queryset = User.objects.filter(role="tutor").order_by("username")
    serializer_class = UserSerializer
    permission_classes = [AllowAny]

    @action(detail=True, methods=["get"])
    def home(self, request, pk=None):
        tutor = self.get_object()
        return Response({
            "id": tutor.id,
            "name": tutor.get_full_name() or tutor.username,
            "email": tutor.email,
        })

    @action(detail=True, methods=["get"])
    def templates(self, request, pk=None):
        tutor = self.get_object()
        templates = Template.objects.filter(created_by=tutor)
        serializer = TemplateSerializer(templates, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=["get"])
    def students(self, request, pk=None):
        tutor = self.get_object()
        data = get_cached_students_for_tutor(tutor)
        return Response(data)

    @action(detail=False, methods=["post"])
    def create_tutor(self, request):
        name = request.data.get("name")
        email = request.data.get("email")
        password = request.data.get("password") or User.objects.make_random_password()

        if not name or not email:
            return Response({"error": "Name and email are required"}, status=400)

        new_tutor = User.objects.create(
            username=email,
            email=email,
            first_name=name,
            role="tutor",
            password=make_password(password),
        )

        TutorProfile.objects.create(tutor=new_tutor)

        return Response({
            "id": new_tutor.id,
            "name": new_tutor.first_name,
            "email": new_tutor.email,
            "password": password
        })

    @action(detail=True, methods=["get"])
    def weekly_availability(self, request, pk=None):
        tutor = self.get_object()
        data = get_cached_weekly_availability(tutor)
        return Response(data)

    @action(detail=True, methods=["get"])
    def availability(self, request, pk=None):
        tutor = self.get_object()

        availability = TutorAvailability.objects.filter(tutor=tutor)
        blocked = TutorBlockedDay.objects.filter(tutor=tutor)

        return Response({
            "availability": [
                {
                    "id": a.id,
                    "weekday": a.weekday,
                    "start_time": a.start_time,
                    "end_time": a.end_time,
                }
                for a in availability
            ],
            "blocked_days": [
                {
                    "id": b.id,
                    "date": b.date,
                }
                for b in blocked
            ]
        })

    @action(detail=True, methods=["post"])
    def add_availability(self, request, pk=None):
        tutor = self.get_object()
        js_weekday = int(request.data["weekday"])
        weekday = (js_weekday - 1) % 7
        start = request.data.get("start_time")
        end = request.data.get("end_time")

        a = TutorAvailability.objects.create(
            tutor=tutor,
            weekday=weekday,
            start_time=start,
            end_time=end,
        )
        invalidate_weekly_slots_cache_for_tutor(tutor.id)

        return Response({"id": a.id})

    @action(detail=True, methods=["post"])
    def remove_availability(self, request, pk=None):
        TutorAvailability.objects.filter(id=request.data.get("id")).delete()
        invalidate_weekly_slots_cache_for_tutor(tutor.id)

        return Response({"status": "ok"})

    @action(detail=True, methods=["post"])
    def block_day(self, request, pk=None):
        tutor = self.get_object()
        date = request.data.get("date")
        b = TutorBlockedDay.objects.create(tutor=tutor, date=date)
        invalidate_weekly_slots_cache_for_tutor(tutor.id)

        return Response({"id": b.id})


    @action(detail=True, methods=["post"])
    def unblock_day(self, request, pk=None):
        TutorBlockedDay.objects.filter(id=request.data.get("id")).delete()
        invalidate_weekly_slots_cache_for_tutor(tutor.id)

        return Response({"status": "ok"})

    @action(detail=True, methods=["get"])
    def weekly_slots(self, request, pk=None):
        # start = time.perf_counter()

        user = self.get_object()
        tutor = user.get_tutor_profile()

        # Optional student
        student_id = request.query_params.get("student")
        student = User.objects.filter(pk=student_id).first() if student_id else None

        # Parse week_start
        week_start_str = request.query_params.get("week_start")
        if not week_start_str:
            return Response({"error": "week_start is required (YYYY-MM-DD)"}, status=400)

        try:
            raw_date = datetime.strptime(week_start_str, "%Y-%m-%d").date()
        except ValueError:
            return Response({"error": "Invalid date format. Use YYYY-MM-DD."}, status=400)

        week_start = get_sunday_start(raw_date)

        # Use cached version
        week_data = get_cached_weekly_slots(tutor, week_start, student)

        # print(f"Weekly slots build took {time.perf_counter() - start:.4f} seconds")

        return Response({"week": week_data}, status=200)

    @action(detail=True, methods=["get"])
    def session_settings(self, request, pk=None):
        user = self.get_object()
        tutor = TutorProfile.objects.get(tutor=user)
        serializer = TutorSerializer(tutor)
        return Response(serializer.data)

    @action(detail=True, methods=["post"], url_path="create_weekly_booking")
    def create_weekly_booking(self, request, pk=None):
        tutor_user = self.get_object()  # the tutor in the URL
        tutor_profile = tutor_user.get_tutor_profile()

        student_id = request.data.get("student_id")
        weekday = request.data.get("weekday")
        time_str = request.data.get("time")
        if isinstance(time_str, str) and len(time_str) >= 5: time_str = time_str[:5]
        print("Create weekly appointment api:", student_id, weekday, time_str)

        if student_id is None or weekday is None or time_str is None:
            return Response(
                {"error": "student_id, weekday, and time are required"},
                status=400
            )

        try:
            weekday = int(weekday)
            if weekday < 0 or weekday > 6:
                raise ValueError()
        except ValueError:
            return Response({"error": "weekday must be an integer 0–6"}, status=400)

        # Parse time
        try:
            start_time = datetime.strptime(time_str, "%H:%M").time()
        except ValueError:
            return Response({"error": "Invalid time format. Use HH:MM"}, status=400)

        try:
            student = User.objects.get(id=student_id)
        except User.DoesNotExist:
            return Response({"error": "Student not found"}, status=404)

        linked_tutor = student.get_tutor()
        if not linked_tutor or linked_tutor.id != tutor_user.id:
            return Response(
                {"error": "This student is not assigned to this tutor"},
                status=403
            )

        try:
            wb = student.create_weekly_booking(weekday, start_time)
        except ValueError as e:
            return Response({"error": str(e)}, status=400)

        invalidate_weekly_availability_cache_for_tutor(tutor_user.id)
        return Response({
            "ok": True,
            "id": wb.id,
            "weekday": wb.weekday,
            "start_time": wb.start_time,
            "end_time": wb.end_time,
            "student_id": student.id,
            "student_name": student.first_name,
        })

    @action(detail=True, methods=["post"], url_path="check_and_book")
    def check_and_book(self, request, pk=None):
        print("Check and book")
        user = self.get_object()
        tutor = user.get_tutor_profile()

        student_id = request.data["student_id"]
        student = User.objects.get(pk=student_id)
        date_requested = request.data["date"]
        time_requested = request.data["time"]
        repeat = request.data.get("repeat_weekly", False)

        # Parse date + time
        date_dt = datetime.fromisoformat(date_requested).date()
        start_t = datetime.strptime(time_requested, "%H:%M").time()

        # Compute end time
        session_minutes = tutor.default_session_minutes
        end_t = (datetime.combine(date_dt, start_t) +
                 timedelta(minutes=session_minutes)).time()

        weeks = 12 if repeat else 1

        created = 0
        results = []  # ← collect success/failure for each week

        for i in range(weeks):
            this_date = date_dt + timedelta(weeks=i)
            print("Check and Book:", this_date)
            # Check availability using your existing logic
            status = tutor.appointment_status(this_date, start_t)

            if status != "available":
                results.append({
                    "week": i + 1,
                    "date": str(this_date),
                    "time": start_t.strftime("%H:%M"),
                    "success": False,
                    "reason": status,
                })
                continue  # ← keep going to next week

            # Build aware datetimes
            naive_start = datetime.combine(this_date, start_t)
            naive_end = datetime.combine(this_date, end_t)
            start_dt = make_aware(naive_start)
            end_dt = make_aware(naive_end)

            try:
                Appointment.objects.create(
                    tutor=user,
                    student_id=student_id,
                    start_datetime=start_dt,
                    end_datetime=end_dt,
                    status="booked",
                    created_by=student,
                )
                created += 1
                results.append({
                    "week": i + 1,
                    "date": str(this_date),
                    "time": start_t.strftime("%H:%M"),
                    "success": True,
                })
            except Exception as e:
                # Database or validation error
                results.append({
                    "week": i + 1,
                    "date": str(this_date),
                    "time": start_t.strftime("%H:%M"),
                    "success": False,
                    "reason": str(e),
                })
        invalidate_weekly_slots_cache_for_tutor(tutor.id)

        return Response({
            "status": "ok" if created > 0 else "error",
            "created": created,
            "results": results,
        })

    @action(detail=True, methods=["post"], url_path="delete_booking")
    def delete_booking(self, request, pk=None):
        user = self.get_object()  # the tutor in tutor_view OR the tutor of the student


        booking_id = request.data.get("booking_id")
        print("Delete Booking (booking_id):", booking_id)
        if not booking_id:
            return Response({"error": "booking_id is required"}, status=400)
        try:
            appt = Appointment.objects.get(id=booking_id)
        except Appointment.DoesNotExist:
            return Response({"error": "Appointment not found"}, status=404)

        invalidate_weekly_slots_cache_for_tutor(appt.tutor.id)

        appt.delete()
        return Response({"status": "ok", "message": "Booking deleted"})
