    def generate_weekly_slots(self, week_start, student=None, tutor_view=False):
        session_td = timedelta(minutes=self.default_session_minutes)
        week = []

        # Build the week skeletonx`
        for i in range(7):
            day_date = week_start + timedelta(days=i)
            week.append({"date": day_date, "bookable_slots": [], "segments": []})

        # ── 1. Fetch all appointments for the week in one query
        week_start_dt = make_aware(datetime.combine(week_start, time.min))
        week_end_dt = make_aware(datetime.combine(week_start + timedelta(days=7), time.min))

        appointments = list(
            Appointment.objects.filter(
                tutor=self.tutor,
                start_datetime__lt=week_end_dt,
                end_datetime__gt=week_start_dt,
            ).select_related("student")
        )

        # Group appointments by date for fast lookup
        appointments_by_date = defaultdict(list)
        for appt in appointments:
            # We care about each date the appointment touches; simplest is to
            # group by the date of the start, which matches your 1‑day slots.
            date_key = appt.start_datetime.date()
            appointments_by_date[date_key].append(appt)

        appt_start_times = defaultdict(set)

        for appt in appointments:
            date_key = appt.start_datetime.date()
            start_time = appt.start_datetime.time().replace(second=0, microsecond=0)
            appt_start_times[date_key].add(start_time)

        # ── 2. Fetch blocked days for the week
        blocked_days = set(
            TutorBlockedDay.objects.filter(
                tutor=self.tutor,
                date__gte=week_start,
                date__lt=week_start + timedelta(days=7),
            ).values_list("date", flat=True)
        )

        # ── 3. Fetch availability windows for the tutor
        availability_by_weekday = {}
        for av in TutorAvailability.objects.filter(tutor=self.tutor):
            availability_by_weekday.setdefault(av.weekday, []).append(av)

        # ── 4. Build segments and bookable slots in memory
        for day in week:
            d = day["date"]

            for minute in range(0, 24 * 60, 15):
                t = (datetime.min + timedelta(minutes=minute)).time()

                status, appt = self.appointment_status_fast(
                    d, t, student,
                    blocked_days,
                    appointments_by_date,
                    availability_by_weekday,
                )

                if tutor_view and status in ("booked_self", "booked_other"):
                    status = "booked_other"

                segment = {"time": t, "type": status}

                if appt:
                    segment["bookingId"] = appt.id
                    if t in appt_start_times[d]:
                        segment["studentName"] = appt.student.first_name

                day["segments"].append(segment)

                # Only compute bookable_slots for available segments
                if status != "available":
                    continue

                end_dt = datetime.combine(d, t) + session_td
                end_t = end_dt.time()

                end_status, _ = self.appointment_status_fast(
                    d,
                    end_t,
                    student,
                    blocked_days,
                    appointments_by_date,
                    availability_by_weekday,
                )

                if end_status == "available":
                    day["bookable_slots"].append(t)

        print("Generate Slots (week):")
        # print(week)

        return week